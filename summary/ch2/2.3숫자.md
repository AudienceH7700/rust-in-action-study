2.3 숫자
==

2.3.1 정수와 부동 소수점 수
---
 - 러스트는 정수와 부동 소수점 수를 만들 때 비교적 관습적인 구문을 쓴다.
 - 숫자에 대한 연산은 중위(infix) 표기법을 사용한다.
   → 일반적인 프로그래밍 언어에서 흔히 볼 수 있는 방식과 비슷
 - 여러 가지 타입에 대한 덧셈을 할때 동일한 토큰(+)을 이용 **(연산자 오버로딩)**
 
 ###### 다른 언어와의 차이점
 - 바이트 단위로 크기를 선언하는 데 익숙해져야 하며, 이는 해당 타입의 수 범위가 어디까지 인지, 음수를 나타낼 수 있는지 영향을 끼친다.
 - **타입 간의 변환은 언제나 명시적으로 일어난다.** 16비트를 32비트 정수로 자동 변환하지 않는다.
 - 러스트의 **수는 메서드**를 가질 수 있다.

<pre><code>
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));
</code></pre>
 - 숫자의 밑줄은 가독성을 위해 작성된 것일 뿐이다.
 - 위 예제에서 볼 수 있듯이 숫자는 메소드를 가질 수 있다.

<pre><code>
  let forty_twos = [
        42.0
        , 42f32
        , 42.0_f32,
  ];

  println!("{:02}", forty_twos[0]);
</code></pre>
 - 배열은 모두 같은 타입이어야 하며 대괄호로 묶어 생성한다.
 - println!() 매크로에서 {:02} 표현은 숫자의 자리수를 2개로 나타내기 위한 표현법
 
2.3.2 이진, 팔진, 십육진법을 이용하는 정수
---
- 러스트는 기본적으로 **이진수, 팔진수, 십육진수**로 **정수 리터럴**을 정의할 수 있다. (이 표기법은 println!과 같은 형식화 매크로에서도 사용할 수 있다)

<pre><code>
 let three = 0b11;
 let thirty = 0o36;
 let three_hundred = 0x12C;

 println!("base 10: {} {} {}", three, thirty, three_hundred);
 println!("base 2: {:b} {:b} {:b}", three, thirty, three_hundred);
 println!("base 8: {:o} {:o} {:o}", three, thirty, three_hundred);
 println!("base 16: {:x} {:x} {:x}", three, thirty, three_hundred);
</code></pre>
 - **0b** 접두사는 **이진수**
 - **0o** 접두사는 **팔진수**
 - **0x** 접두사는 **십육진수**

2.3.3 수의 비교
---
- 러스트는 다른 언어와 비슷한 비교 연산자를 사용한다.
- 다른 언어와 다른 점은 아래와 같다

###### 서로 다른 데이터 타입은 비교할 수 없다.
- 서로 다른 타입은 **as** 연산자를 사용하여 다른 타입으로 변환해야 한다.
<pre><code>
 let a: i32 = 10;
 let b: u16 = 100;
 
 if a < (b as i32) {
  println!("Ten is less than one hundred!");
 }
</code></pre>
- **일반적으로 작은 타입을 큰 타입으로 변환하는 것이 가장 안전한다. (승격 promotion)**



